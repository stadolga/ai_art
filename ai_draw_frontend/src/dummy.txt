const [drawingHistory, setDrawingHistory] = useState([]);

const startDrawing = (event) => {
  event.preventDefault();
  const x = event.nativeEvent.offsetX * 1.5;
  const y = event.nativeEvent.offsetY * 1.5;
  if (contextRef.current === null) return;
  contextRef.current.beginPath();
  contextRef.current.moveTo(x, y);
  setIsDrawing(true);

  const currentDrawing = {
    color: color,
    brush: brush,
    x: x,
    y: y
  }
  setDrawingHistory([...drawingHistory, currentDrawing]);
};

const clearCanvas = () => {
  if(drawingHistory.length === 0) // ja joku toinen check
  {
    setDrawingHistory(drawingHistory.slice(0, -1));
    }
const canvas = canvasRef.current;
const context = canvas.getContext('2d');
context.fillStyle = 'white';
context.fillRect(0, 0, canvas.width, canvas.height);
};

const finishDrawing = () => {
//salee lisää täs kohtaa
contextRef.current.closePath();
setIsDrawing(false);

const undo = () => {
const canvas = canvasRef.current;
const context = canvas.getContext('2d');
context.fillStyle = 'white';
context.fillRect(0, 0, canvas.width, canvas.height);
setDrawingHistory(drawingHistory.pop()) //remove the latest component

for (let i = 0; i < drawingHistory.length; i++) {
  context.strokeStyle = `rgba(${drawingHistory[i].color.r}, ${drawingHistory[i].color.g}, ${drawingHistory[i].color.b}, ${drawingHistory[i].color.a})`;
  context.lineWidth = drawingHistory[i].brush;
  context.beginPath();
  context.moveTo(drawingHistory[i].x, drawingHistory[i].y);
  context.lineTo(event.nativeEvent.offsetX * 1.5, event.nativeEvent.offsetY * 1.5);
  context.stroke();
  context.closePath();
}

}

